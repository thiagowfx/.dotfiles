#!/bin/bash
# Base shell functions for bash and zsh.

# Adds an alias.
#   $1 What alias to create.
#   $2 The value to alias to.
#   $3 Optional. If provided will only alias if the program exists.
add_alias() {
        [ -n "$3" ] && ! hash "$3" >/dev/null 2>&1 && return

        # shellcheck disable=SC2139
        alias "$1"="$2"
}

# Exports a shell environment variable ($1) to the first of the rest of the
# arguments that exist.
set_env() {
        local f var="$1"; shift
        for f in "$@"; do
                hash "$f" >/dev/null 2>&1 && export "$var"="$f"
                return
        done
}

# Adds paths to $PATH if they exist.
path_munge() {
        local f
        for f in "$@"; do
                if [ -d "$f" ] && ! grep -E -q "(^|:)$f($|:)" <<< "$PATH"; then
                        PATH="$f:$PATH"
                fi
        done
}

# Sources the given files and directories (recursively) if they exist.
#   $1 If "--shallow" is provided, directories will not be recursed.
src_files() {
        [ "$1" = "--shallow" ] && local shallow=1 && shift

        for f in "$@"; do
                # Source directories recursively if --shallow is not specified.
                if [ -d "$f" ]; then
                        if [ -n "$shallow" ]; then
                                # Use process substitution to avoid spawning a subshell.
                                # https://stackoverflow.com/questions/13726764/while-loop-subshell-dilemma-in-bash
                                while read -r -d $'\0' s; do
                                        # shellcheck source=/dev/null
                                        . "$s" || true
                                done < <(find "$f" -maxdepth 1 -type f -print0)
                        else
                                src_files "$f"/* || true
                        fi
                        # Source files.
                elif [ -f "$f" ]; then
                        # shellcheck source=/dev/null
                        . "$f" || true
                fi
        done
}
