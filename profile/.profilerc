#!/usr/bin/env bash

# shellcheck source=/dev/null
# Base shell functions for bash and zsh.

# Add paths to $PATH if they exist.
# Usage: path_munge "$HOME/.bin" "$HOME/bin"
path_munge() {
        local f
        for f in "$@"; do
                if [ -d "$f" ] && ! grep -E -q "(^|:)$f($|:)" <<< "$PATH"; then
                        PATH="$f:$PATH"
                fi
        done
}

# Sensible $PATH should include user binary directories.
#   pipx uses $HOME/.local/bin
path_munge "$HOME/.bin" "$HOME/bin" "$HOME/.local/bin"

# bd: back directory (delete current directory with confirmation)
# Usage: bd or bd <directory>
bd() {
	if [ -z "$1" ]; then
		dir="$PWD"
		builtin cd ..
		printf "Delete '%s'? (y/n) " "$dir"
		read -r response
		case "$response" in
			[Yy]) rm -rf "$dir" ;;
		esac
	else
		builtin cd "$1"
	fi
}

# Augmented cd with path substitution support.
# Usage: cd [directory] or cd <find> <replace>
#   cd main develop           - switch branch: /projects/myapp/main/src -> /projects/myapp/develop/src
#   cd v1 v2                  - switch version: /app/v1/build -> /app/v2/build
#   cd prod staging           - switch environment: /var/www/prod/api -> /var/www/staging/api
cd() {
	if [ $# -eq 2 ]; then
		local find="$1" replace="$2"
		local new_pwd="${PWD//$find/$replace}"
		builtin cd "$new_pwd" || return
	else
		builtin cd "$@" || return
	fi
}

# Inspiration from https://frantic.im/cdtmp/ and grml-zsh-config's cdt
# Usage: cdtmp [foo]
# Creates temp dir with user, date, and optional prefix
cdtmp() {
	builtin cd "$(mktemp -d -t "$USER-${1:+$1-}$(date +%Y-%m-%d)-XXXXXX")" || return
	builtin pwd
}

# Source files and directories recursively if they exist.
# Usage: src_files "/usr/local/etc/bashrc.d/" "/usr/share/doc/pkgfile/command-not-found.bash"
src_files() {
        local f
        for f in "$@"; do
                # Source directories.
                if [ -d "$f" ]; then
                        src_files "$f"/* || true
                # Source files.
                elif [ -f "$f" ]; then
                        . "$f" || true
                fi
        done
}

# Colorize CLI output when supported.
export CLICOLOR=1

# Set preferred text editor (fallback if nvim not yet in PATH).
# See .profile.d/alias.sh for nvim setup after Homebrew PATH is configured.
command -v vim >/dev/null 2>&1 && export EDITOR="vim" VISUAL="vim"

# Configure less pager if available.
if command -v less >/dev/null 2>&1; then
        # Set sensible defaults for less.
        # https://stackoverflow.com/a/14118014/1745064
        export LESS="-FR"

        # Enhanced man pages
        #   Color: https://wiki.archlinux.org/title/Color_output_in_console#man
        #   Progress percentage: https://unix.stackexchange.com/a/329092/41858
        export MANPAGER="less -R -s -M +Gg"

        if [ "$(less -V | head -n 1 | cut -f2 -d' ' | xargs printf '%.0f')" -ge 580 ]; then
                export MANPAGER="${MANPAGER} --use-color -Dd+r -Du+b"
        else
                man() {
                        # shellcheck disable=SC3003
                        LESS_TERMCAP_md=$'\e[01;31m' \
                                LESS_TERMCAP_me=$'\e[0m' \
                                LESS_TERMCAP_se=$'\e[0m' \
                                LESS_TERMCAP_so=$'\e[01;44;33m' \
                                LESS_TERMCAP_ue=$'\e[0m' \
                                LESS_TERMCAP_us=$'\e[01;34m' \
                                command man "$@"
                }
        fi
fi

# vim: ft=sh
